#
# Copyright (c) 2024 Dmitry Arkhipov (grisumbras@yandex.ru)
#
# Distributed under the Boost Software License, Version 1.0. (See accompanying
# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
#

import importlib.util
import io
import re
import sys

embedder = sys.argv[1]
printers = sys.argv[2]

embedder_spec = importlib.util.spec_from_file_location(
    '_gdb_embedder', embedder)
embedder_mod = importlib.util.module_from_spec(embedder_spec)
embedder_spec.loader.exec_module(embedder_mod)

def embed(*args):
    stdout = io.StringIO()
    embedder_mod.main([embedder, printers, *args], sys.stdin, stdout)
    return stdout.getvalue()

def test(output, sample):
    sample = sample.split('\n')
    for n, l in enumerate(output.split('\n')):
        try:
            if (sample[n] ==
                    r'  ".ascii \"\\4gdb.inlined-script.0.XXXX\\n\"\n"'):
                assert re.match(
                    r'^  ".ascii \\"\\\\4gdb\.inlined-script\.0\.\d+\\\\n\\"\\n"$',
                    l)
            else:
                assert l == sample[n]
        except AssertionError:
            print('mismatch on line %d:' % n)
            print('got:      %s' % l)
            print('expected: %s' % sample[n])
            raise

test(embed(), r'''//
// Copyright (c) 2024 Dmitry Arkhipov (grisumbras@yandex.ru)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Autogenerated from gdb.py by boost-debugger-utils

#ifndef BOOST_ALL_NO_EMBEDDED_GDB_SCRIPTS

#if defined(__ELF__)

#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Woverlength-strings"
#elif defined(__GNUC__)
# pragma GCC diagnostic push
# pragma GCC diagnostic ignored "-Woverlength-strings"
#endif

__asm__(
  ".pushsection \".debug_gdb_scripts\", \"MS\",@progbits,1\n"
  ".ascii \"\\4gdb.inlined-script.0.XXXX\\n\"\n"
  ".ascii \"import gdb\\n\"\n"
  ".ascii \"import gdb.printing\\n\"\n"


  ".ascii \"collection = gdb.printing.RegexpCollectionPrettyPrinter(\\n\"\n"
  ".ascii \"    'BoostDebuggerUtilsTest')\\n\"\n"
  ".ascii \"def register(printer, ns=None, template=False):\\n\"\n"
  ".ascii \"    typename = getattr(printer, '__name__')\\n\"\n"
  ".ascii \"    ns = ns or 'testlib'\\n\"\n"
  ".ascii \"    collection.add_printer(\\n\"\n"
  ".ascii \"        typename,\\n\"\n"
  ".ascii \"        '^{ns}::{typename}{marker}'.format(\\n\"\n"
  ".ascii \"            ns=ns,\\n\"\n"
  ".ascii \"            typename=typename,\\n\"\n"
  ".ascii \"            marker='<'if template else '$'),\\n\"\n"
  ".ascii \"        printer)\\n\"\n"


  ".ascii \"class key_value_pair:\\n\"\n"
  ".ascii \"    def __init__(self, val):\\n\"\n"
  ".ascii \"        self.val = val\\n\"\n"

  ".ascii \"    def to_string(self):\\n\"\n"
  ".ascii \"        return 'key_value_pair[%s = %s]' % (\\n\"\n"
  ".ascii \"            self.val['key'], self.val['value'])\\n\"\n"
  ".ascii \"register(key_value_pair)\\n\"\n"


  ".ascii \"class memory_resource:\\n\"\n"
  ".ascii \"    def __init__(self, val):\\n\"\n"
  ".ascii \"        self.val = val\\n\"\n"

  ".ascii \"    def to_string(self):\\n\"\n"
  ".ascii \"        void_star = gdb.lookup_type('void').pointer()\\n\"\n"
  ".ascii \"        return 'memory_resource[buffer=%s, size=%s]' % (\\n\"\n"
  ".ascii \"            self.val['buffer'].cast(void_star), self.val['size'])\\n\"\n"
  ".ascii \"register(memory_resource)\\n\"\n"


  ".ascii \"obj_file = gdb.current_objfile()\\n\"\n"
  ".ascii \"mod = obj_file or gdb\\n\"\n"
  ".ascii \"should_run = True\\n\"\n"
  ".ascii \"for printer in getattr(mod, 'pretty_printers', []):\\n\"\n"
  ".ascii \"    if getattr(printer, 'name') == collection.name:\\n\"\n"
  ".ascii \"        should_run = False\\n\"\n"
  ".ascii \"if should_run:\\n\"\n"
  ".ascii \"    gdb.printing.register_pretty_printer(obj_file, collection)\\n\"\n"
  ".byte 0\n"
  ".popsection\n");
#if defined(__clang__)
#  pragma clang diagnostic pop
#elif defined(__GNUC__)
#  pragma GCC diagnostic pop
#endif

#endif // defined(__ELF__)

#endif // BOOST_ALL_NO_EMBEDDED_GDB_SCRIPTS
''')

test(embed('--header-guard=FOO'), r'''//
// Copyright (c) 2024 Dmitry Arkhipov (grisumbras@yandex.ru)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Autogenerated from gdb.py by boost-debugger-utils

#ifndef FOO
#define FOO

#ifndef BOOST_ALL_NO_EMBEDDED_GDB_SCRIPTS

#if defined(__ELF__)

#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Woverlength-strings"
#elif defined(__GNUC__)
# pragma GCC diagnostic push
# pragma GCC diagnostic ignored "-Woverlength-strings"
#endif

__asm__(
  ".pushsection \".debug_gdb_scripts\", \"MS\",@progbits,1\n"
  ".ascii \"\\4gdb.inlined-script.FOO\\n\"\n"
  ".ascii \"import gdb\\n\"\n"
  ".ascii \"import gdb.printing\\n\"\n"


  ".ascii \"collection = gdb.printing.RegexpCollectionPrettyPrinter(\\n\"\n"
  ".ascii \"    'BoostDebuggerUtilsTest')\\n\"\n"
  ".ascii \"def register(printer, ns=None, template=False):\\n\"\n"
  ".ascii \"    typename = getattr(printer, '__name__')\\n\"\n"
  ".ascii \"    ns = ns or 'testlib'\\n\"\n"
  ".ascii \"    collection.add_printer(\\n\"\n"
  ".ascii \"        typename,\\n\"\n"
  ".ascii \"        '^{ns}::{typename}{marker}'.format(\\n\"\n"
  ".ascii \"            ns=ns,\\n\"\n"
  ".ascii \"            typename=typename,\\n\"\n"
  ".ascii \"            marker='<'if template else '$'),\\n\"\n"
  ".ascii \"        printer)\\n\"\n"


  ".ascii \"class key_value_pair:\\n\"\n"
  ".ascii \"    def __init__(self, val):\\n\"\n"
  ".ascii \"        self.val = val\\n\"\n"

  ".ascii \"    def to_string(self):\\n\"\n"
  ".ascii \"        return 'key_value_pair[%s = %s]' % (\\n\"\n"
  ".ascii \"            self.val['key'], self.val['value'])\\n\"\n"
  ".ascii \"register(key_value_pair)\\n\"\n"


  ".ascii \"class memory_resource:\\n\"\n"
  ".ascii \"    def __init__(self, val):\\n\"\n"
  ".ascii \"        self.val = val\\n\"\n"

  ".ascii \"    def to_string(self):\\n\"\n"
  ".ascii \"        void_star = gdb.lookup_type('void').pointer()\\n\"\n"
  ".ascii \"        return 'memory_resource[buffer=%s, size=%s]' % (\\n\"\n"
  ".ascii \"            self.val['buffer'].cast(void_star), self.val['size'])\\n\"\n"
  ".ascii \"register(memory_resource)\\n\"\n"


  ".ascii \"obj_file = gdb.current_objfile()\\n\"\n"
  ".ascii \"mod = obj_file or gdb\\n\"\n"
  ".ascii \"should_run = True\\n\"\n"
  ".ascii \"for printer in getattr(mod, 'pretty_printers', []):\\n\"\n"
  ".ascii \"    if getattr(printer, 'name') == collection.name:\\n\"\n"
  ".ascii \"        should_run = False\\n\"\n"
  ".ascii \"if should_run:\\n\"\n"
  ".ascii \"    gdb.printing.register_pretty_printer(obj_file, collection)\\n\"\n"
  ".byte 0\n"
  ".popsection\n");
#if defined(__clang__)
#  pragma clang diagnostic pop
#elif defined(__GNUC__)
#  pragma GCC diagnostic pop
#endif

#endif // defined(__ELF__)

#endif // BOOST_ALL_NO_EMBEDDED_GDB_SCRIPTS

#endif // FOO
''')

test(embed('--disable-macro=DISABLE'), r'''//
// Copyright (c) 2024 Dmitry Arkhipov (grisumbras@yandex.ru)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Autogenerated from gdb.py by boost-debugger-utils

#ifndef DISABLE

#if defined(__ELF__)

#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Woverlength-strings"
#elif defined(__GNUC__)
# pragma GCC diagnostic push
# pragma GCC diagnostic ignored "-Woverlength-strings"
#endif

__asm__(
  ".pushsection \".debug_gdb_scripts\", \"MS\",@progbits,1\n"
  ".ascii \"\\4gdb.inlined-script.0.XXXX\\n\"\n"
  ".ascii \"import gdb\\n\"\n"
  ".ascii \"import gdb.printing\\n\"\n"


  ".ascii \"collection = gdb.printing.RegexpCollectionPrettyPrinter(\\n\"\n"
  ".ascii \"    'BoostDebuggerUtilsTest')\\n\"\n"
  ".ascii \"def register(printer, ns=None, template=False):\\n\"\n"
  ".ascii \"    typename = getattr(printer, '__name__')\\n\"\n"
  ".ascii \"    ns = ns or 'testlib'\\n\"\n"
  ".ascii \"    collection.add_printer(\\n\"\n"
  ".ascii \"        typename,\\n\"\n"
  ".ascii \"        '^{ns}::{typename}{marker}'.format(\\n\"\n"
  ".ascii \"            ns=ns,\\n\"\n"
  ".ascii \"            typename=typename,\\n\"\n"
  ".ascii \"            marker='<'if template else '$'),\\n\"\n"
  ".ascii \"        printer)\\n\"\n"


  ".ascii \"class key_value_pair:\\n\"\n"
  ".ascii \"    def __init__(self, val):\\n\"\n"
  ".ascii \"        self.val = val\\n\"\n"

  ".ascii \"    def to_string(self):\\n\"\n"
  ".ascii \"        return 'key_value_pair[%s = %s]' % (\\n\"\n"
  ".ascii \"            self.val['key'], self.val['value'])\\n\"\n"
  ".ascii \"register(key_value_pair)\\n\"\n"


  ".ascii \"class memory_resource:\\n\"\n"
  ".ascii \"    def __init__(self, val):\\n\"\n"
  ".ascii \"        self.val = val\\n\"\n"

  ".ascii \"    def to_string(self):\\n\"\n"
  ".ascii \"        void_star = gdb.lookup_type('void').pointer()\\n\"\n"
  ".ascii \"        return 'memory_resource[buffer=%s, size=%s]' % (\\n\"\n"
  ".ascii \"            self.val['buffer'].cast(void_star), self.val['size'])\\n\"\n"
  ".ascii \"register(memory_resource)\\n\"\n"


  ".ascii \"obj_file = gdb.current_objfile()\\n\"\n"
  ".ascii \"mod = obj_file or gdb\\n\"\n"
  ".ascii \"should_run = True\\n\"\n"
  ".ascii \"for printer in getattr(mod, 'pretty_printers', []):\\n\"\n"
  ".ascii \"    if getattr(printer, 'name') == collection.name:\\n\"\n"
  ".ascii \"        should_run = False\\n\"\n"
  ".ascii \"if should_run:\\n\"\n"
  ".ascii \"    gdb.printing.register_pretty_printer(obj_file, collection)\\n\"\n"
  ".byte 0\n"
  ".popsection\n");
#if defined(__clang__)
#  pragma clang diagnostic pop
#elif defined(__GNUC__)
#  pragma GCC diagnostic pop
#endif

#endif // defined(__ELF__)

#endif // DISABLE
''')

test(embed('--disable-macro='), r'''//
// Copyright (c) 2024 Dmitry Arkhipov (grisumbras@yandex.ru)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Autogenerated from gdb.py by boost-debugger-utils

#if defined(__ELF__)

#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Woverlength-strings"
#elif defined(__GNUC__)
# pragma GCC diagnostic push
# pragma GCC diagnostic ignored "-Woverlength-strings"
#endif

__asm__(
  ".pushsection \".debug_gdb_scripts\", \"MS\",@progbits,1\n"
  ".ascii \"\\4gdb.inlined-script.0.XXXX\\n\"\n"
  ".ascii \"import gdb\\n\"\n"
  ".ascii \"import gdb.printing\\n\"\n"


  ".ascii \"collection = gdb.printing.RegexpCollectionPrettyPrinter(\\n\"\n"
  ".ascii \"    'BoostDebuggerUtilsTest')\\n\"\n"
  ".ascii \"def register(printer, ns=None, template=False):\\n\"\n"
  ".ascii \"    typename = getattr(printer, '__name__')\\n\"\n"
  ".ascii \"    ns = ns or 'testlib'\\n\"\n"
  ".ascii \"    collection.add_printer(\\n\"\n"
  ".ascii \"        typename,\\n\"\n"
  ".ascii \"        '^{ns}::{typename}{marker}'.format(\\n\"\n"
  ".ascii \"            ns=ns,\\n\"\n"
  ".ascii \"            typename=typename,\\n\"\n"
  ".ascii \"            marker='<'if template else '$'),\\n\"\n"
  ".ascii \"        printer)\\n\"\n"


  ".ascii \"class key_value_pair:\\n\"\n"
  ".ascii \"    def __init__(self, val):\\n\"\n"
  ".ascii \"        self.val = val\\n\"\n"

  ".ascii \"    def to_string(self):\\n\"\n"
  ".ascii \"        return 'key_value_pair[%s = %s]' % (\\n\"\n"
  ".ascii \"            self.val['key'], self.val['value'])\\n\"\n"
  ".ascii \"register(key_value_pair)\\n\"\n"


  ".ascii \"class memory_resource:\\n\"\n"
  ".ascii \"    def __init__(self, val):\\n\"\n"
  ".ascii \"        self.val = val\\n\"\n"

  ".ascii \"    def to_string(self):\\n\"\n"
  ".ascii \"        void_star = gdb.lookup_type('void').pointer()\\n\"\n"
  ".ascii \"        return 'memory_resource[buffer=%s, size=%s]' % (\\n\"\n"
  ".ascii \"            self.val['buffer'].cast(void_star), self.val['size'])\\n\"\n"
  ".ascii \"register(memory_resource)\\n\"\n"


  ".ascii \"obj_file = gdb.current_objfile()\\n\"\n"
  ".ascii \"mod = obj_file or gdb\\n\"\n"
  ".ascii \"should_run = True\\n\"\n"
  ".ascii \"for printer in getattr(mod, 'pretty_printers', []):\\n\"\n"
  ".ascii \"    if getattr(printer, 'name') == collection.name:\\n\"\n"
  ".ascii \"        should_run = False\\n\"\n"
  ".ascii \"if should_run:\\n\"\n"
  ".ascii \"    gdb.printing.register_pretty_printer(obj_file, collection)\\n\"\n"
  ".byte 0\n"
  ".popsection\n");
#if defined(__clang__)
#  pragma clang diagnostic pop
#elif defined(__GNUC__)
#  pragma GCC diagnostic pop
#endif

#endif // defined(__ELF__)
''')
